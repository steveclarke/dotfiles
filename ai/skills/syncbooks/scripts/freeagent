#!/usr/bin/env ruby
# frozen_string_literal: true

require "bundler/inline"

gemfile do
  source "https://rubygems.org"
  gem "thor"
  gem "httparty"
  gem "webrick"
  gem "shale"
end

require "json"
require "time"
require "date"
require "fileutils"
require "webrick"
require "uri"

require_relative "lib/models"

class SyncBooksConfig
  CONFIG_PATH = File.expand_path("~/.config/syncbooks/config.json")

  def self.load
    return {} unless File.exist?(CONFIG_PATH)
    JSON.parse(File.read(CONFIG_PATH))
  rescue
    {}
  end

  def self.save(config)
    FileUtils.mkdir_p(File.dirname(CONFIG_PATH))
    File.write(CONFIG_PATH, JSON.pretty_generate(config))
  end

  def self.get(key)
    load[key]
  end

  def self.set(key, value)
    config = load
    config[key] = value
    save(config)
  end

  # HST period helpers
  def self.hst_period_start
    date_str = get("hst_period_start")
    date_str ? Date.parse(date_str) : current_quarter_start
  end

  def self.hst_period_start=(date)
    set("hst_period_start", date.to_s)
  end

  def self.current_quarter_start
    today = Date.today
    quarter_month = ((today.month - 1) / 3) * 3 + 1
    Date.new(today.year, quarter_month, 1)
  end

  def self.next_quarter_start(from_date = nil)
    from_date ||= hst_period_start
    # Add 3 months to get next quarter
    month = from_date.month + 3
    year = from_date.year
    if month > 12
      month -= 12
      year += 1
    end
    Date.new(year, month, 1)
  end

  def self.quarter_name(date)
    quarter = ((date.month - 1) / 3) + 1
    "Q#{quarter} #{date.year}"
  end
end

class FreeAgentClient
  BASE_URL = "https://api.freeagent.com/v2"
  TOKEN_URL = "https://api.freeagent.com/v2/token_endpoint"
  CREDENTIALS_PATH = File.expand_path("~/.local/share/syncbooks/credentials.json")

  # 1Password references
  OP_CLIENT_ID = "op://Employee/FreeAgent API - SyncBooks/username"
  OP_CLIENT_SECRET = "op://Employee/FreeAgent API - SyncBooks/credential"

  def initialize
    load_config!
    raise "FreeAgent not configured. Run initial OAuth setup first." if @access_token.nil? || @access_token.empty?
  end

  def load_config!
    # Load tokens from credentials file (these refresh and need persistence)
    if File.exist?(CREDENTIALS_PATH)
      creds = JSON.parse(File.read(CREDENTIALS_PATH))
      fa = creds["freeagent"] || {}
      @access_token = fa["access_token"]
      @refresh_token = fa["refresh_token"]
      @token_expiry = fa["token_expiry"]
    end

    # Get client credentials from 1Password (primary) or env vars (fallback)
    @client_id = op_read(OP_CLIENT_ID) || ENV["FREEAGENT_CLIENT_ID"]
    @client_secret = op_read(OP_CLIENT_SECRET) || ENV["FREEAGENT_CLIENT_SECRET"]

    # Fall back to env vars for tokens if not in credentials file
    @access_token ||= ENV["FREEAGENT_API_KEY"]
    @refresh_token ||= ENV["FREEAGENT_REFRESH_TOKEN"]
  end

  def op_read(ref)
    warn "Fetching #{ref.split("/").last} from 1Password..."
    result = `op read '#{ref}' 2>/dev/null`.chomp
    result.empty? ? nil : result
  rescue
    nil
  end

  def save_credentials!
    creds = File.exist?(CREDENTIALS_PATH) ? JSON.parse(File.read(CREDENTIALS_PATH)) : {}
    creds["freeagent"] ||= {}
    creds["freeagent"]["access_token"] = @access_token
    creds["freeagent"]["refresh_token"] = @refresh_token
    creds["freeagent"]["token_expiry"] = @token_expiry

    FileUtils.mkdir_p(File.dirname(CREDENTIALS_PATH))
    File.write(CREDENTIALS_PATH, JSON.pretty_generate(creds))
    File.chmod(0o600, CREDENTIALS_PATH)
  end

  # Contacts
  def contacts(view: "active")
    data = get("/contacts?view=#{view}")["contacts"] || []
    parse_collection(data, SyncBooks::Models::Contact)
  end

  def contact(id)
    data = get("/contacts/#{id}")["contact"]
    SyncBooks::Models::Contact.from_hash(data)
  end

  def create_contact(attrs)
    data = post("/contacts", {contact: attrs})["contact"]
    SyncBooks::Models::Contact.from_hash(data)
  end

  def find_contact_by_name(name)
    contacts.find do |c|
      c.name&.downcase == name.downcase
    end
  end

  # Invoices
  def invoices(view: "recent", nested_invoice_items: true)
    params = "view=#{view}&nested_invoice_items=#{nested_invoice_items}"
    data = get("/invoices?#{params}")["invoices"] || []
    parse_collection(data, SyncBooks::Models::Invoice)
  end

  def invoice(id)
    data = get("/invoices/#{id}")["invoice"]
    SyncBooks::Models::Invoice.from_hash(data)
  end

  def create_invoice(attrs)
    data = post("/invoices", {invoice: attrs})["invoice"]
    SyncBooks::Models::Invoice.from_hash(data)
  end

  def mark_invoice_sent(id)
    put("/invoices/#{id}/transitions/mark_as_sent", {})
  end

  # Projects (for invoice creation)
  def projects(contact_id: nil)
    url = "/projects"
    url += "?contact=#{BASE_URL}/contacts/#{contact_id}" if contact_id
    get(url)["projects"]
  end

  # Company info
  def company
    get("/company")["company"]
  end

  # Bank accounts
  def bank_accounts
    data = get("/bank_accounts")["bank_accounts"] || []
    parse_collection(data, SyncBooks::Models::BankAccount)
  end

  # Bank transaction explanations for an account
  def bank_transaction_explanations(bank_account_url, from_date:, to_date:)
    encoded_url = URI.encode_www_form_component(bank_account_url)
    get_all_pages("/bank_transaction_explanations?bank_account=#{encoded_url}&from_date=#{from_date}&to_date=#{to_date}")
  end

  # Invoices with date filter (returns raw hashes for HST calculation)
  def invoices_by_date(from_date:, to_date:)
    data = get_all_pages("/invoices?from_date=#{from_date}&to_date=#{to_date}")
    parse_collection(data, SyncBooks::Models::Invoice)
  end

  # Bills with date filter
  def bills(from_date:, to_date:)
    data = get_all_pages("/bills?from_date=#{from_date}&to_date=#{to_date}")
    parse_collection(data, SyncBooks::Models::Bill)
  end

  # Bills by view (open, overdue, etc)
  def bills_by_view(view:)
    data = get("/bills?view=#{view}")["bills"] || []
    parse_collection(data, SyncBooks::Models::Bill)
  end

  # Expenses with date filter
  def expenses(from_date:, to_date:)
    data = get_all_pages("/expenses?from_date=#{from_date}&to_date=#{to_date}")
    parse_collection(data, SyncBooks::Models::Expense)
  end

  private

  def parse_collection(data, model_class)
    return [] if data.nil? || data.empty?
    data.map { |item| model_class.from_hash(item) }
  end

  def get_all_pages(endpoint)
    all_items = []
    page = 1
    loop do
      sep = endpoint.include?("?") ? "&" : "?"
      url = "#{endpoint}#{sep}page=#{page}&per_page=100"
      response = get(url)
      # Find the array in the response (first key with array value)
      items = response.values.find { |v| v.is_a?(Array) }
      break if items.nil? || items.empty?
      all_items.concat(items)
      break if items.length < 100
      page += 1
      break if page > 50 # Safety limit
    end
    all_items
  end

  def get(endpoint, retry_count: 0)
    response = HTTParty.get(
      "#{BASE_URL}#{endpoint}",
      headers: auth_headers
    )
    result = handle_response(response, retry_count: retry_count)
    return get(endpoint, retry_count: retry_count + 1) if result == :retry
    result
  end

  def post(endpoint, body, retry_count: 0)
    response = HTTParty.post(
      "#{BASE_URL}#{endpoint}",
      headers: auth_headers.merge("Content-Type" => "application/json"),
      body: body.to_json
    )
    result = handle_response(response, retry_count: retry_count)
    return post(endpoint, body, retry_count: retry_count + 1) if result == :retry
    result
  end

  def put(endpoint, body, retry_count: 0)
    response = HTTParty.put(
      "#{BASE_URL}#{endpoint}",
      headers: auth_headers.merge("Content-Type" => "application/json"),
      body: body.to_json
    )
    result = handle_response(response, retry_count: retry_count)
    return put(endpoint, body, retry_count: retry_count + 1) if result == :retry
    result
  end

  def auth_headers
    {"Authorization" => "Bearer #{@access_token}"}
  end

  def handle_response(response, retry_count: 0)
    return response.parsed_response if response.success?

    if response.code == 401 && can_refresh? && retry_count == 0
      warn "Token expired, refreshing..."
      refresh_token!
      return :retry
    end

    raise "FreeAgent API error: #{response.code} - #{response.body}"
  end

  def can_refresh?
    @refresh_token && @client_id && @client_secret
  end

  def refresh_token!
    response = HTTParty.post(
      TOKEN_URL,
      headers: {"Content-Type" => "application/x-www-form-urlencoded"},
      body: {
        grant_type: "refresh_token",
        refresh_token: @refresh_token,
        client_id: @client_id,
        client_secret: @client_secret
      }
    )

    if response.success?
      data = response.parsed_response
      @access_token = data["access_token"]
      @refresh_token = data["refresh_token"] if data["refresh_token"]
      @token_expiry = (Time.now + (data["expires_in"] || 3600)).utc.to_s

      save_credentials!
      warn "Token refreshed and saved to #{CREDENTIALS_PATH}"
    else
      raise "Failed to refresh token: #{response.body}"
    end
  end
end

class CLI < Thor
  REDIRECT_URI = "http://localhost:8080/callback"
  AUTH_URL = "https://api.freeagent.com/v2/approve_app"
  TOKEN_URL = "https://api.freeagent.com/v2/token_endpoint"

  def self.exit_on_failure?
    true
  end

  # === Auth Commands ===

  desc "auth", "Configure FreeAgent OAuth credentials"
  option :clear, type: :boolean, default: false, desc: "Clear stored credentials"
  def auth
    if options[:clear]
      clear_credentials!
      puts "FreeAgent credentials cleared."
      return
    end

    # Get client credentials from 1Password
    client_id = op_read(FreeAgentClient::OP_CLIENT_ID)
    client_secret = op_read(FreeAgentClient::OP_CLIENT_SECRET)

    unless client_id && client_secret
      raise Thor::Error, "Could not load credentials from 1Password. Ensure op CLI is authenticated."
    end

    puts "FreeAgent OAuth Configuration"
    puts "=" * 50
    puts ""

    # Build authorization URL
    auth_url = "#{AUTH_URL}?response_type=code&client_id=#{URI.encode_www_form_component(client_id)}&redirect_uri=#{URI.encode_www_form_component(REDIRECT_URI)}"

    puts "Step 1: Opening browser for authorization..."
    puts ""
    puts "If the browser doesn't open, visit:"
    puts auth_url
    puts ""

    # Open browser
    system("open", auth_url) if RUBY_PLATFORM.include?("darwin")

    puts "Step 2: Waiting for authorization callback..."
    puts "(Listening on #{REDIRECT_URI})"
    puts ""

    # Start local server and wait for callback
    code = wait_for_callback

    unless code
      raise Thor::Error, "Authorization failed or timed out."
    end

    puts "Authorization code received."
    puts ""
    puts "Step 3: Exchanging code for access tokens..."
    puts ""

    # Exchange code for tokens
    response = HTTParty.post(
      TOKEN_URL,
      headers: {"Content-Type" => "application/x-www-form-urlencoded"},
      body: {
        grant_type: "authorization_code",
        code: code,
        client_id: client_id,
        client_secret: client_secret,
        redirect_uri: REDIRECT_URI
      }
    )

    unless response.success?
      raise Thor::Error, "Token exchange failed: #{response.body}"
    end

    data = response.parsed_response
    save_tokens!(data)

    puts "FreeAgent OAuth configured successfully!"
    puts "Credentials saved to #{FreeAgentClient::CREDENTIALS_PATH}"
    puts ""
    puts "Run 'freeagent company' to verify the connection."
  end

  # === Contact Commands ===

  desc "contacts", "List contacts"
  option :view, default: "active", desc: "View: active, all, clients, suppliers"
  def contacts
    data = client.contacts(view: options[:view]).map do |c|
      {
        id: c.id,
        name: c.display_name,
        email: c.email,
        status: c.status
      }
    end
    puts JSON.pretty_generate(data)
  end

  desc "contact ID", "Show contact details"
  def contact(id)
    c = client.contact(id)
    puts JSON.pretty_generate(
      id: c.id,
      organisation_name: c.organisation_name,
      first_name: c.first_name,
      last_name: c.last_name,
      email: c.email,
      country: c.country,
      status: c.status
    )
  end

  desc "create-contact", "Create a new contact"
  option :organisation, aliases: "-o", desc: "Organisation name"
  option :first_name, aliases: "-f", desc: "First name"
  option :last_name, aliases: "-l", desc: "Last name"
  option :email, aliases: "-e", desc: "Email address"
  option :billing_email, desc: "Billing email (defaults to email)"
  option :phone, aliases: "-p", desc: "Phone number"
  option :address, aliases: "-a", desc: "Street address"
  option :town, desc: "City/Town"
  option :region, desc: "Province/State/Region"
  option :postcode, desc: "Postal/ZIP code"
  option :country, default: "Canada", desc: "Country"
  option :payment_terms, aliases: "-t", type: :numeric, default: 30, desc: "Payment terms in days"
  def create_contact
    attrs = {}
    attrs[:organisation_name] = options[:organisation] if options[:organisation]
    attrs[:first_name] = options[:first_name] if options[:first_name]
    attrs[:last_name] = options[:last_name] if options[:last_name]
    attrs[:email] = options[:email] if options[:email]
    attrs[:billing_email] = options[:billing_email] || options[:email]
    attrs[:phone_number] = options[:phone] if options[:phone]
    attrs[:address1] = options[:address] if options[:address]
    attrs[:town] = options[:town] if options[:town]
    attrs[:region] = options[:region] if options[:region]
    attrs[:postcode] = options[:postcode] if options[:postcode]
    attrs[:country] = options[:country]
    attrs[:default_payment_terms_in_days] = options[:payment_terms]
    attrs[:locale] = "en"
    attrs[:charge_sales_tax] = "Auto"

    if attrs[:organisation_name].nil? && (attrs[:first_name].nil? || attrs[:last_name].nil?)
      raise Thor::Error, "Must provide --organisation OR both --first-name and --last-name"
    end

    contact = client.create_contact(attrs)
    puts JSON.pretty_generate(
      id: contact.id,
      name: contact.display_name,
      email: contact.email
    )
    puts "Contact created successfully."
  end

  # === Invoice Commands ===

  desc "invoices", "List invoices"
  option :view, default: "recent", desc: "View: recent, open, all, overdue, draft"
  def invoices
    data = client.invoices(view: options[:view]).map do |inv|
      {
        id: inv.id,
        reference: inv.reference,
        contact_id: inv.contact_id,
        dated_on: inv.dated_on,
        due_on: inv.due_on,
        status: inv.status,
        total: inv.display_total,
        currency: inv.currency
      }
    end
    puts JSON.pretty_generate(data)
  end

  desc "invoice ID", "Show invoice details"
  def invoice(id)
    inv = client.invoice(id)
    puts JSON.pretty_generate(
      id: inv.id,
      reference: inv.reference,
      contact_id: inv.contact_id,
      dated_on: inv.dated_on,
      due_on: inv.due_on,
      status: inv.status,
      net_value: inv.net_value,
      sales_tax_value: inv.sales_tax_value,
      total_value: inv.total_value,
      currency: inv.currency
    )
  end

  desc "create-invoice", "Create a new invoice"
  option :contact, aliases: "-c", required: true, desc: "Contact ID or name"
  option :reference, aliases: "-r", desc: "Invoice reference/number"
  option :date, aliases: "-d", default: Date.today.to_s, desc: "Invoice date (YYYY-MM-DD)"
  option :due_days, aliases: "-t", type: :numeric, default: 30, desc: "Payment terms in days"
  option :currency, default: "CAD", desc: "Currency code"
  option :description, aliases: "-D", required: true, desc: "Line item description"
  option :quantity, aliases: "-q", type: :numeric, default: 1, desc: "Quantity"
  option :price, aliases: "-p", required: true, type: :numeric, desc: "Price per unit"
  option :item_type, default: "Services", desc: "Item type: Hours, Days, Services, Products"
  option :tax_rate, type: :numeric, default: 15.0, desc: "Sales tax rate (%)"
  option :send, type: :boolean, default: false, desc: "Mark as sent after creation"
  def create_invoice
    # Resolve contact
    contact_id = resolve_contact(options[:contact])
    contact_url = "#{FreeAgentClient::BASE_URL}/contacts/#{contact_id}"

    dated_on = Date.parse(options[:date])
    due_on = dated_on + options[:due_days]

    attrs = {
      contact: contact_url,
      dated_on: dated_on.to_s,
      due_on: due_on.to_s,
      payment_terms_in_days: options[:due_days],
      currency: options[:currency],
      invoice_items: [
        {
          description: options[:description],
          item_type: options[:item_type],
          quantity: options[:quantity].to_s,
          price: options[:price].to_s,
          sales_tax_rate: options[:tax_rate].to_s
        }
      ]
    }
    attrs[:reference] = options[:reference] if options[:reference]

    inv = client.create_invoice(attrs)

    if options[:send]
      client.mark_invoice_sent(inv.id)
      puts "Invoice marked as sent."
    end

    puts JSON.pretty_generate(
      id: inv.id,
      reference: inv.reference,
      dated_on: inv.dated_on,
      due_on: inv.due_on,
      status: inv.status,
      total_value: inv.display_total,
      currency: inv.currency
    )
    puts "Invoice created successfully."
  end

  # === Utility Commands ===

  desc "company", "Show company info"
  def company
    data = client.company
    puts JSON.pretty_generate(
      name: data["name"],
      type: data["type"],
      currency: data["currency"],
      country: data["company_registration_number"],
      sales_tax_registration_number: data["sales_tax_registration_number"]
    )
  end

  desc "projects", "List projects"
  option :contact, aliases: "-c", desc: "Filter by contact ID"
  def projects
    data = client.projects(contact_id: options[:contact]).map do |p|
      {
        id: extract_id(p["url"]),
        name: p["name"],
        contact_id: extract_id(p["contact"]),
        status: p["status"],
        budget: p["budget"],
        currency: p["currency"]
      }
    end
    puts JSON.pretty_generate(data)
  end

  desc "hst", "Calculate HST report (defaults: period start to today)"
  option :from, aliases: "-f", desc: "Start date (YYYY-MM-DD), defaults to HST period start"
  option :to, aliases: "-t", desc: "End date (YYYY-MM-DD), defaults to today"
  def hst
    from_date = options[:from] || SyncBooksConfig.hst_period_start.to_s
    to_date = options[:to] || Date.today.to_s

    period_start = SyncBooksConfig.hst_period_start
    quarter_name = SyncBooksConfig.quarter_name(period_start)

    puts "HST Report: #{from_date} to #{to_date}"
    puts "Period start: #{period_start} (#{quarter_name})"
    puts "=" * 60
    puts ""

    hst_charged, hst_reclaimed, details = calculate_hst(from_date, to_date)

    # Summary
    puts ""
    puts "-" * 60
    puts "BREAKDOWN"
    puts "-" * 60
    puts ""
    puts "HST Charged (on sales):"
    puts "  Invoices:                      $%12.2f" % details[:inv_hst]
    puts "  Bank transactions (income):    $%12.2f" % details[:bank_charged]
    puts "  %-30s $%12.2f" % ["TOTAL CHARGED:", hst_charged]
    puts ""
    puts "HST Reclaimed (on purchases):"
    puts "  Bills:                         $%12.2f" % details[:bills_hst]
    puts "  Expenses:                      $%12.2f" % details[:exp_hst]
    puts "  Bank transactions (expenses):  $%12.2f" % details[:bank_reclaimed]
    puts "  %-30s $%12.2f" % ["TOTAL RECLAIMED:", hst_reclaimed]
    puts ""
    puts "=" * 60
    puts "%-32s $%12.2f" % ["NET HST OWING TO CRA:", hst_charged - hst_reclaimed]
    puts "=" * 60
  end

  desc "hst-paid", "Mark HST quarter as paid and advance to next quarter"
  option :confirm, type: :boolean, default: false, desc: "Skip confirmation prompt"
  def hst_paid
    current_start = SyncBooksConfig.hst_period_start
    current_quarter = SyncBooksConfig.quarter_name(current_start)
    next_start = SyncBooksConfig.next_quarter_start
    next_quarter = SyncBooksConfig.quarter_name(next_start)

    puts "HST Period Update"
    puts "=" * 50
    puts ""
    puts "Current period start: #{current_start} (#{current_quarter})"
    puts "New period start:     #{next_start} (#{next_quarter})"
    puts ""

    unless options[:confirm]
      print "Advance HST period to #{next_quarter}? (y/N) "
      response = $stdin.gets&.chomp&.downcase
      unless response == "y"
        puts "Cancelled."
        return
      end
    end

    SyncBooksConfig.hst_period_start = next_start
    puts ""
    puts "HST period advanced to #{next_quarter} (starting #{next_start})."
    puts "Run 'freeagent hst' to see the new period totals."
  end

  desc "hst-set DATE", "Set HST period start date (e.g., 2025-10-01)"
  def hst_set(date)
    parsed_date = Date.parse(date)
    SyncBooksConfig.hst_period_start = parsed_date
    puts "HST period start set to #{parsed_date} (#{SyncBooksConfig.quarter_name(parsed_date)})."
  rescue ArgumentError
    raise Thor::Error, "Invalid date format. Use YYYY-MM-DD."
  end

  desc "hst-status", "Show current HST period configuration"
  def hst_status
    period_start = SyncBooksConfig.hst_period_start
    quarter_name = SyncBooksConfig.quarter_name(period_start)
    next_quarter = SyncBooksConfig.next_quarter_start
    days_in_period = (Date.today - period_start).to_i

    puts "HST Period Status"
    puts "=" * 50
    puts ""
    puts "Period start:     #{period_start} (#{quarter_name})"
    puts "Today:            #{Date.today}"
    puts "Days in period:   #{days_in_period}"
    puts "Next quarter:     #{next_quarter} (#{SyncBooksConfig.quarter_name(next_quarter)})"
    puts ""
    puts "Config file: #{SyncBooksConfig::CONFIG_PATH}"
  end

  desc "sync", "Sync FreeAgent data to Google Sheets"
  option :force, aliases: "-f", type: :boolean, default: false, desc: "Allow writes to non-dev spreadsheets"
  def sync
    sheets_script = File.expand_path("../sheets", __FILE__)

    puts "Syncing FreeAgent data to Google Sheets"
    puts "=" * 50
    puts ""

    # 1. Calculate HST
    from_date = SyncBooksConfig.hst_period_start.to_s
    to_date = Date.today.to_s
    puts "HST Period: #{from_date} to #{to_date}"
    puts ""

    hst_charged, hst_reclaimed, _details = calculate_hst(from_date, to_date)
    puts ""

    # 2. Get balance
    print "Fetching balance..."
    accounts = client.bank_accounts.select(&:active?)
    balance_total = accounts.sum { |a| a.current_balance || 0 }
    puts " $#{"%.2f" % balance_total}"

    # 3. Get outstanding invoices (open + overdue)
    print "Fetching open invoices..."
    open_invoices = client.invoices(view: "open")
    open_total = open_invoices.sum { |i| i.total_value || 0 }
    puts " #{open_invoices.length} invoices ($#{"%.2f" % open_total})"

    print "Fetching overdue invoices..."
    overdue_invoices = client.invoices(view: "overdue")
    overdue_total = overdue_invoices.sum { |i| i.total_value || 0 }
    puts " #{overdue_invoices.length} invoices ($#{"%.2f" % overdue_total})"

    invoices_total = open_total + overdue_total

    # 4. Get outstanding bills (open + overdue)
    print "Fetching open bills..."
    open_bills = client.bills_by_view(view: "open")
    open_bills_total = open_bills.sum { |b| b.total_value || 0 }
    puts " #{open_bills.length} bills ($#{"%.2f" % open_bills_total})"

    print "Fetching overdue bills..."
    overdue_bills = client.bills_by_view(view: "overdue")
    overdue_bills_total = overdue_bills.sum { |b| b.total_value || 0 }
    puts " #{overdue_bills.length} bills ($#{"%.2f" % overdue_bills_total})"

    bills_total = open_bills_total + overdue_bills_total
    puts ""

    # 3. Write to sheets
    puts "-" * 50
    puts "Writing to Google Sheets..."
    puts ""

    force_flag = options[:force] ? "--force" : ""

    # E2: HST Collected
    `#{sheets_script} write "Main!E2" "#{format("%.2f", hst_charged)}" #{force_flag} 2>&1`
    puts "  E2 (HST Collected):    $#{"%.2f" % hst_charged}"

    # E3: HST Reclaimed
    `#{sheets_script} write "Main!E3" "#{format("%.2f", hst_reclaimed)}" #{force_flag} 2>&1`
    puts "  E3 (HST Reclaimed):    $#{"%.2f" % hst_reclaimed}"

    # E6: Available COH
    `#{sheets_script} write "Main!E6" "#{format("%.2f", balance_total)}" #{force_flag} 2>&1`
    puts "  E6 (Available COH):    $#{"%.2f" % balance_total}"

    # E9: FA Invoices (outstanding)
    `#{sheets_script} write "Main!E9" "#{format("%.2f", invoices_total)}" #{force_flag} 2>&1`
    puts "  E9 (FA Invoices):      $#{"%.2f" % invoices_total}"

    # B4: Outstanding Bills
    `#{sheets_script} write "Main!B4" "#{format("%.2f", bills_total)}" #{force_flag} 2>&1`
    puts "  B4 (Outstanding Bills): $#{"%.2f" % bills_total}"

    puts ""
    puts "=" * 50
    puts "Sync complete!"
    puts ""
    puts "Run 'sheets summary' to see updated cash position."
  end

  desc "balance", "Show total balance across all bank accounts"
  def balance
    accounts = client.bank_accounts.select(&:active?)

    if accounts.empty?
      puts "No active bank accounts found."
      return
    end

    # Group by type
    bank_accts = accounts.select(&:bank?)
    credit_cards = accounts.select(&:credit_card?)
    paypal = accounts.select(&:paypal?)

    # Calculate totals
    bank_total = bank_accts.sum { |a| a.current_balance || 0 }
    credit_total = credit_cards.sum { |a| a.current_balance || 0 }
    paypal_total = paypal.sum { |a| a.current_balance || 0 }
    total = accounts.sum { |a| a.current_balance || 0 }

    currency = accounts.first.currency || "CAD"

    puts "FreeAgent Total Balance"
    puts "=" * 50
    puts ""
    puts "Active Accounts:"
    accounts.each do |a|
      puts "  %-30s %s %12.2f" % [a.name, a.currency, a.current_balance || 0]
    end
    puts ""
    puts "-" * 50
    puts "Total by Type:"
    puts "  %-30s %s %12.2f" % ["Bank Accounts:", currency, bank_total]
    puts "  %-30s %s %12.2f" % ["Credit Cards:", currency, credit_total]
    puts "  %-30s %s %12.2f" % ["PayPal:", currency, paypal_total]
    puts ""
    puts "%-32s %s %12.2f" % ["TOTAL BALANCE:", currency, total]
    puts "=" * 50
  end

  private

  def calculate_hst(from_date, to_date)
    hst_charged = 0.0
    hst_reclaimed = 0.0
    details = {}

    # 1. Invoices - HST charged on sales
    print "Fetching invoices..."
    invoices = client.invoices_by_date(from_date: from_date, to_date: to_date)
    details[:inv_hst] = invoices.sum { |i| i.sales_tax_value || 0 }
    hst_charged += details[:inv_hst]
    puts " #{invoices.length} invoices"

    # 2. Bills - HST reclaimed on purchases
    print "Fetching bills..."
    bills = client.bills(from_date: from_date, to_date: to_date)
    details[:bills_hst] = bills.sum { |b| (b.sales_tax_value || 0).abs }
    hst_reclaimed += details[:bills_hst]
    puts " #{bills.length} bills"

    # 3. Expenses - HST reclaimed
    print "Fetching expenses..."
    expenses = client.expenses(from_date: from_date, to_date: to_date)
    details[:exp_hst] = expenses.sum { |e| e.hst_amount }
    hst_reclaimed += details[:exp_hst]
    puts " #{expenses.length} expenses"

    # 4. Bank transaction explanations (still raw hashes - no model yet)
    print "Fetching bank transactions..."
    accounts = client.bank_accounts.select(&:active?)
    details[:bank_charged] = 0.0
    details[:bank_reclaimed] = 0.0
    total_txns = 0

    accounts.each do |acc|
      exps = client.bank_transaction_explanations(acc.url, from_date: from_date, to_date: to_date)
      total_txns += exps.length
      exps.each do |e|
        stv = e["sales_tax_value"]
        next unless stv

        val = stv.to_f.abs
        cat = e["category"]&.split("/")&.last.to_i
        if cat < 100 # Income category
          details[:bank_charged] += val
        else # Expense category
          details[:bank_reclaimed] += val
        end
      end
    end
    puts " #{total_txns} transactions"

    hst_charged += details[:bank_charged]
    hst_reclaimed += details[:bank_reclaimed]

    [hst_charged, hst_reclaimed, details]
  end

  def client
    @client ||= FreeAgentClient.new
  end

  def extract_id(url)
    return nil unless url
    url.split("/").last
  end

  def resolve_contact(input)
    # If numeric, assume it's an ID
    return input if input.match?(/^\d+$/)

    # Otherwise search by name
    contact = client.find_contact_by_name(input)
    raise Thor::Error, "Contact not found: #{input}" unless contact

    contact.id
  end

  def op_read(ref)
    warn "Fetching #{ref.split("/").last} from 1Password..."
    result = `op read '#{ref}' 2>/dev/null`.chomp
    result.empty? ? nil : result
  rescue
    nil
  end

  def wait_for_callback
    code = nil
    server = WEBrick::HTTPServer.new(
      Port: 8080,
      Logger: WEBrick::Log.new(File::NULL),
      AccessLog: []
    )

    server.mount_proc "/callback" do |req, res|
      code = req.query["code"]
      res.content_type = "text/html"
      res.body = <<~HTML
        <!DOCTYPE html>
        <html>
          <head><title>Authorization Successful</title></head>
          <body style="font-family: sans-serif; text-align: center; padding: 50px;">
            <h1 style="color: #28a745;">Authorization Successful!</h1>
            <p>You can close this window and return to the terminal.</p>
          </body>
        </html>
      HTML
      server.shutdown
    end

    # Timeout after 5 minutes
    Thread.new do
      sleep 300
      server.shutdown if server.status == :Running
    end

    server.start
    code
  end

  def save_tokens!(data)
    creds_path = FreeAgentClient::CREDENTIALS_PATH
    creds = File.exist?(creds_path) ? JSON.parse(File.read(creds_path)) : {}
    creds["freeagent"] ||= {}
    creds["freeagent"]["access_token"] = data["access_token"]
    creds["freeagent"]["refresh_token"] = data["refresh_token"]
    creds["freeagent"]["token_expiry"] = (Time.now + (data["expires_in"] || 3600)).utc.to_s

    FileUtils.mkdir_p(File.dirname(creds_path))
    File.write(creds_path, JSON.pretty_generate(creds))
    File.chmod(0o600, creds_path)
  end

  def clear_credentials!
    creds_path = FreeAgentClient::CREDENTIALS_PATH
    return unless File.exist?(creds_path)

    creds = JSON.parse(File.read(creds_path))
    creds["freeagent"] = {}
    File.write(creds_path, JSON.pretty_generate(creds))
  end
end

CLI.start(ARGV)

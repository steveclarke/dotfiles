#!/usr/bin/env ruby
# frozen_string_literal: true

require "bundler/inline"

gemfile do
  source "https://rubygems.org"
  gem "thor"
  gem "httparty"
  gem "webrick"
end

require "json"
require "time"
require "fileutils"
require "webrick"
require "uri"

class GoogleSheetsClient
  BASE_URL = "https://sheets.googleapis.com/v4/spreadsheets"
  AUTH_URL = "https://accounts.google.com/o/oauth2/v2/auth"
  TOKEN_URL = "https://oauth2.googleapis.com/token"
  CREDENTIALS_PATH = File.expand_path("~/.local/share/syncbooks/credentials.json")
  SCOPES = "https://www.googleapis.com/auth/spreadsheets"

  # 1Password references
  OP_CLIENT_ID = "op://Employee/Google Sheets API - SyncBooks/client id"
  OP_CLIENT_SECRET = "op://Employee/Google Sheets API - SyncBooks/client secret"
  OP_SPREADSHEET_ID = "op://Employee/Google Sheets API - SyncBooks/cash-on-hand-sheet-id"
  OP_SPREADSHEET_ID_DEV = "op://Employee/Google Sheets API - SyncBooks/cash-on-hand-sheet-id-dev"

  attr_reader :spreadsheet_id

  def initialize(spreadsheet_id: nil, dev: false)
    @spreadsheet_id = spreadsheet_id || load_spreadsheet_id(dev: dev)
    load_config!
    raise "Google Sheets not configured. Run 'sheets auth' first." if @access_token.nil? || @access_token.empty?
  end

  def load_config!
    if File.exist?(CREDENTIALS_PATH)
      creds = JSON.parse(File.read(CREDENTIALS_PATH))
      gs = creds["google_sheets"] || {}
      @access_token = gs["access_token"]
      @refresh_token = gs["refresh_token"]
      @token_expiry = gs["token_expiry"]
    end

    @client_id = op_read(OP_CLIENT_ID) || ENV["SYNCBOOKS_GOOGLE_CLIENT_ID"]
    @client_secret = op_read(OP_CLIENT_SECRET) || ENV["SYNCBOOKS_GOOGLE_CLIENT_SECRET"]

    @access_token ||= ENV["SYNCBOOKS_GOOGLE_API_KEY"]
    @refresh_token ||= ENV["SYNCBOOKS_GOOGLE_REFRESH_TOKEN"]
  end

  def op_read(ref)
    warn "Fetching #{ref.split("/").last} from 1Password..."
    result = `op read '#{ref}' 2>/dev/null`.chomp
    result.empty? ? nil : result
  rescue
    nil
  end

  def load_spreadsheet_id(dev:)
    ref = dev ? OP_SPREADSHEET_ID_DEV : OP_SPREADSHEET_ID
    id = op_read(ref)
    raise "Could not load spreadsheet ID from 1Password (#{ref})" unless id
    id
  end

  def save_credentials!
    creds = File.exist?(CREDENTIALS_PATH) ? JSON.parse(File.read(CREDENTIALS_PATH)) : {}
    creds["google_sheets"] ||= {}
    creds["google_sheets"]["access_token"] = @access_token
    creds["google_sheets"]["refresh_token"] = @refresh_token
    creds["google_sheets"]["token_expiry"] = @token_expiry

    FileUtils.mkdir_p(File.dirname(CREDENTIALS_PATH))
    File.write(CREDENTIALS_PATH, JSON.pretty_generate(creds))
    File.chmod(0o600, CREDENTIALS_PATH)
  end

  # Read values from a range
  def read(range)
    encoded_range = URI.encode_www_form_component(range)
    get("/#{@spreadsheet_id}/values/#{encoded_range}")
  end

  # Write values to a range
  def write(range, values)
    encoded_range = URI.encode_www_form_component(range)
    body = {values: values.is_a?(Array) ? values : [[values]]}
    put("/#{@spreadsheet_id}/values/#{encoded_range}?valueInputOption=USER_ENTERED", body)
  end

  # Get spreadsheet metadata
  def metadata(fields: "properties.title,sheets.properties")
    get("/#{@spreadsheet_id}?fields=#{fields}")
  end

  # Get spreadsheet title
  def title
    data = metadata(fields: "properties.title")
    data.dig("properties", "title")
  end

  # Check if this is a dev spreadsheet
  def dev_spreadsheet?
    title&.downcase&.include?("(dev)")
  end

  private

  def get(endpoint, retry_count: 0)
    response = HTTParty.get(
      "#{BASE_URL}#{endpoint}",
      headers: auth_headers
    )
    result = handle_response(response, retry_count: retry_count)
    return get(endpoint, retry_count: retry_count + 1) if result == :retry
    result
  end

  def put(endpoint, body, retry_count: 0)
    response = HTTParty.put(
      "#{BASE_URL}#{endpoint}",
      headers: auth_headers.merge("Content-Type" => "application/json"),
      body: body.to_json
    )
    result = handle_response(response, retry_count: retry_count)
    return put(endpoint, body, retry_count: retry_count + 1) if result == :retry
    result
  end

  def auth_headers
    {"Authorization" => "Bearer #{@access_token}"}
  end

  def handle_response(response, retry_count: 0)
    return response.parsed_response if response.success?

    if response.code == 401 && can_refresh? && retry_count == 0
      warn "Token expired, refreshing..."
      refresh_token!
      return :retry
    end

    error = response.parsed_response&.dig("error", "message") || response.body
    raise "Google Sheets API error: #{response.code} - #{error}"
  end

  def can_refresh?
    @refresh_token && @client_id && @client_secret
  end

  def refresh_token!
    response = HTTParty.post(
      TOKEN_URL,
      headers: {"Content-Type" => "application/x-www-form-urlencoded"},
      body: {
        grant_type: "refresh_token",
        refresh_token: @refresh_token,
        client_id: @client_id,
        client_secret: @client_secret
      }
    )

    if response.success?
      data = response.parsed_response
      @access_token = data["access_token"]
      @refresh_token = data["refresh_token"] if data["refresh_token"]
      @token_expiry = (Time.now + (data["expires_in"] || 3600)).utc.to_s

      save_credentials!
      warn "Token refreshed and saved to #{CREDENTIALS_PATH}"
    else
      raise "Failed to refresh token: #{response.body}"
    end
  end
end

class CLI < Thor
  REDIRECT_URI = "http://localhost:8080/callback"

  def self.exit_on_failure?
    true
  end

  # === Auth Commands ===

  desc "auth", "Authenticate with Google Sheets"
  option :clear, type: :boolean, default: false, desc: "Clear stored credentials"
  def auth
    if options[:clear]
      clear_credentials!
      puts "Google Sheets credentials cleared."
      return
    end

    client_id = op_read(GoogleSheetsClient::OP_CLIENT_ID)
    client_secret = op_read(GoogleSheetsClient::OP_CLIENT_SECRET)

    unless client_id && client_secret
      raise Thor::Error, "Could not load credentials from 1Password. Ensure op CLI is authenticated."
    end

    puts "Google Sheets OAuth Configuration"
    puts "=" * 50
    puts ""

    auth_params = {
      client_id: client_id,
      redirect_uri: REDIRECT_URI,
      response_type: "code",
      scope: GoogleSheetsClient::SCOPES,
      access_type: "offline",
      prompt: "consent"
    }
    auth_url = "#{GoogleSheetsClient::AUTH_URL}?#{URI.encode_www_form(auth_params)}"

    puts "Step 1: Opening browser for authorization..."
    puts ""
    puts "If the browser doesn't open, visit:"
    puts auth_url
    puts ""

    system("open", auth_url) if RUBY_PLATFORM.include?("darwin")

    puts "Step 2: Waiting for authorization callback..."
    puts "(Listening on #{REDIRECT_URI})"
    puts ""

    code = wait_for_callback

    unless code
      raise Thor::Error, "Authorization failed or timed out."
    end

    puts "Authorization code received."
    puts ""
    puts "Step 3: Exchanging code for access tokens..."
    puts ""

    response = HTTParty.post(
      GoogleSheetsClient::TOKEN_URL,
      headers: {"Content-Type" => "application/x-www-form-urlencoded"},
      body: {
        grant_type: "authorization_code",
        code: code,
        client_id: client_id,
        client_secret: client_secret,
        redirect_uri: REDIRECT_URI
      }
    )

    unless response.success?
      raise Thor::Error, "Token exchange failed: #{response.body}"
    end

    data = response.parsed_response
    save_tokens!(data)

    puts "Google Sheets OAuth configured successfully!"
    puts "Credentials saved to #{GoogleSheetsClient::CREDENTIALS_PATH}"
    puts ""
    puts "Run 'sheets info' to verify the connection."
  end

  # === Read/Write Commands ===

  desc "read RANGE", "Read cells from spreadsheet (e.g., 'Main!E2:E10')"
  option :spreadsheet, aliases: "-s", desc: "Spreadsheet ID (overrides default)"
  option :dev, type: :boolean, default: false, desc: "Use dev spreadsheet"
  def read(range)
    data = client(spreadsheet_id: options[:spreadsheet], dev: options[:dev]).read(range)
    values = data["values"] || []

    if values.empty?
      puts "No values found in range: #{range}"
    else
      puts "Values from #{range}:"
      puts "-" * 40
      values.each_with_index do |row, i|
        puts "  Row #{i + 1}: #{row.join(" | ")}"
      end
    end
  end

  desc "write RANGE VALUE", "Write to a cell (e.g., 'Main!E2' '1234.56')"
  option :spreadsheet, aliases: "-s", desc: "Spreadsheet ID (overrides default)"
  option :dev, type: :boolean, default: false, desc: "Use dev spreadsheet"
  option :force, aliases: "-f", type: :boolean, default: false, desc: "Skip production safety check"
  def write(range, value)
    c = client(spreadsheet_id: options[:spreadsheet], dev: options[:dev])

    unless options[:force] || options[:dev]
      raise Thor::Error, <<~ERROR
        SAFETY CHECK FAILED

        Write operations are blocked for production spreadsheet.
        Spreadsheet title: "#{c.title}"

        Use --dev flag to write to dev spreadsheet, or --force to write to production.
      ERROR
    end

    result = c.write(range, value)

    puts "Write successful!"
    puts "  Updated cells: #{result["updatedCells"]}"
    puts "  Updated range: #{result["updatedRange"]}"
  end

  # === Info Commands ===

  desc "summary", "Show key financial metrics from spreadsheet"
  option :spreadsheet, aliases: "-s", desc: "Spreadsheet ID (overrides default)"
  option :dev, type: :boolean, default: false, desc: "Use dev spreadsheet"
  def summary
    c = client(spreadsheet_id: options[:spreadsheet], dev: options[:dev])

    # Fetch all key cells in one batch
    data = c.read("Main!A2:B11")
    liabilities = data["values"] || []

    data = c.read("Main!D2:E14")
    assets = data["values"] || []

    puts "Cash Position Summary"
    puts "=" * 50
    puts ""

    # Liabilities section (column A-B)
    puts "LIABILITIES"
    puts "-" * 50
    puts format("  %-30s %15s", "HST Owing:", liabilities.dig(0, 1) || "-")
    puts format("  %-30s %15s", "Payroll Remittance:", liabilities.dig(1, 1) || "-")
    puts format("  %-30s %15s", "Outstanding Bills:", liabilities.dig(2, 1) || "-")
    puts format("  %-30s %15s", "Expenses Due (Steve):", liabilities.dig(7, 1) || "-")
    puts format("  %-30s %15s", "Expenses Due (Clint):", liabilities.dig(8, 1) || "-")
    puts "-" * 50
    puts format("  %-30s %15s", "TOTAL LIABILITIES:", liabilities.dig(9, 1) || "-")
    puts ""

    # Assets section (column D-E)
    puts "POSITION"
    puts "-" * 50
    puts format("  %-30s %15s", "HST Collected:", assets.dig(0, 1) || "-")
    puts format("  %-30s %15s", "HST Reclaimed:", assets.dig(1, 1) || "-")
    puts ""
    puts format("  %-30s %15s", "Available COH:", assets.dig(4, 1) || "-")
    puts format("  %-30s %15s", "Net COH:", assets.dig(5, 1) || "-")
    puts ""
    puts format("  %-30s %15s", "FA Invoices:", assets.dig(7, 1) || "-")
    puts format("  %-30s %15s", "WHMCS Invoices:", assets.dig(8, 1) || "-")
    puts format("  %-30s %15s", "Total Invoices:", assets.dig(9, 1) || "-")
    puts ""
    puts format("  %-30s %15s", "Potentially Available:", assets.dig(10, 1) || "-")
    puts format("  %-30s %15s", "WIP:", assets.dig(11, 1) || "-")
    puts "=" * 50
    puts format("  %-30s %15s", "TOTAL WITH WIP:", assets.dig(12, 1) || "-")
    puts "=" * 50
  end

  desc "info", "Show spreadsheet info"
  option :spreadsheet, aliases: "-s", desc: "Spreadsheet ID (overrides default)"
  option :dev, type: :boolean, default: false, desc: "Use dev spreadsheet"
  def info
    c = client(spreadsheet_id: options[:spreadsheet], dev: options[:dev])
    data = c.metadata

    puts "Spreadsheet Info"
    puts "=" * 50
    puts ""
    puts "Title: #{data.dig("properties", "title")}"
    puts "ID:    #{c.spreadsheet_id}"
    puts "Dev:   #{c.dev_spreadsheet? ? "Yes" : "No"}"
    puts ""
    puts "Sheets:"
    (data["sheets"] || []).each do |sheet|
      props = sheet["properties"]
      puts "  - #{props["title"]} (ID: #{props["sheetId"]})"
    end
  end

  private

  def client(spreadsheet_id: nil, dev: false)
    @client ||= GoogleSheetsClient.new(spreadsheet_id: spreadsheet_id, dev: dev)
  end

  def op_read(ref)
    warn "Fetching #{ref.split("/").last} from 1Password..."
    result = `op read '#{ref}' 2>/dev/null`.chomp
    result.empty? ? nil : result
  rescue
    nil
  end

  def wait_for_callback
    code = nil
    server = WEBrick::HTTPServer.new(
      Port: 8080,
      Logger: WEBrick::Log.new(File::NULL),
      AccessLog: []
    )

    server.mount_proc "/callback" do |req, res|
      code = req.query["code"]
      res.content_type = "text/html"
      res.body = <<~HTML
        <!DOCTYPE html>
        <html>
          <head><title>Authorization Successful</title></head>
          <body style="font-family: sans-serif; text-align: center; padding: 50px;">
            <h1 style="color: #28a745;">Authorization Successful!</h1>
            <p>You can close this window and return to the terminal.</p>
          </body>
        </html>
      HTML
      server.shutdown
    end

    Thread.new do
      sleep 300
      server.shutdown if server.status == :Running
    end

    server.start
    code
  end

  def save_tokens!(data)
    creds_path = GoogleSheetsClient::CREDENTIALS_PATH
    creds = File.exist?(creds_path) ? JSON.parse(File.read(creds_path)) : {}
    creds["google_sheets"] ||= {}
    creds["google_sheets"]["access_token"] = data["access_token"]
    creds["google_sheets"]["refresh_token"] = data["refresh_token"]
    creds["google_sheets"]["token_expiry"] = (Time.now + (data["expires_in"] || 3600)).utc.to_s

    FileUtils.mkdir_p(File.dirname(creds_path))
    File.write(creds_path, JSON.pretty_generate(creds))
    File.chmod(0o600, creds_path)
  end

  def clear_credentials!
    creds_path = GoogleSheetsClient::CREDENTIALS_PATH
    return unless File.exist?(creds_path)

    creds = JSON.parse(File.read(creds_path))
    creds["google_sheets"] = {}
    File.write(creds_path, JSON.pretty_generate(creds))
  end
end

CLI.start(ARGV)

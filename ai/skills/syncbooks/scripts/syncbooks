#!/usr/bin/env ruby
# frozen_string_literal: true

require "bundler/inline"

gemfile do
  source "https://rubygems.org"
  gem "thor"
  gem "httparty"
  gem "webrick"
  gem "shale"
  gem "gum"
end

require "json"
require "time"
require "date"
require "fileutils"
require "uri"

# Load all SyncBooks modules
require_relative "lib/syncbooks"

module SyncBooks
  class CLI < Thor
    def self.exit_on_failure?
      true
    end

    # Register subcommands with aliases
    register Commands::Auth, "auth", "auth SUBCOMMAND", "Authentication commands"
    register Commands::Sheets, "sheets", "sheets SUBCOMMAND", "Google Sheets commands"
    register Commands::Sheets, "sh", "sh SUBCOMMAND", "Google Sheets commands (alias)"
    register Commands::WHMCS, "whmcs", "whmcs SUBCOMMAND", "WHMCS billing commands"
    register Commands::WHMCS, "wh", "wh SUBCOMMAND", "WHMCS billing commands (alias)"

    # FreeAgent alias - maps fa:X to freeagent X commands
    desc "fa SUBCOMMAND", "FreeAgent commands (alias for balance, invoices, contacts, etc.)"
    subcommand "fa", Class.new(Thor) {
      def self.exit_on_failure?
        true
      end

      desc "balance", "Show total balance across all bank accounts"
      def balance
        SyncBooks::CLI.new.balance
      end

      desc "invoices", "List invoices"
      option :view, default: "recent", desc: "View: recent, open, all, overdue, draft"
      option :json, type: :boolean, default: false, desc: "Output as JSON"
      def invoices
        SyncBooks::CLI.new.invoke(:invoices, [], options)
      end

      desc "contacts", "List contacts"
      option :view, default: "active", desc: "View: active, all, clients, suppliers"
      option :json, type: :boolean, default: false, desc: "Output as JSON"
      def contacts
        SyncBooks::CLI.new.invoke(:contacts, [], options)
      end

      desc "hst", "Calculate HST report"
      option :from, aliases: "-f", desc: "Start date (YYYY-MM-DD)"
      option :to, aliases: "-t", desc: "End date (YYYY-MM-DD)"
      def hst
        SyncBooks::CLI.new.invoke(:hst, [], options)
      end

      desc "company", "Show company info"
      def company
        SyncBooks::CLI.new.company
      end

      desc "projects", "List projects"
      option :contact, aliases: "-c", desc: "Filter by contact ID"
      def projects
        SyncBooks::CLI.new.invoke(:projects, [], options)
      end
    }

    # === Setup ===

    desc "setup", "Cache all credentials from 1Password (run once)"
    option :refresh, type: :boolean, default: false, desc: "Force refresh from 1Password"
    def setup
      if Config.setup_complete? && !options[:refresh]
        puts "Setup already complete. Use --refresh to re-fetch from 1Password."
        puts ""
        puts "Config file: #{Config::CONFIG_PATH}"
        return
      end

      puts "SyncBooks Setup"
      puts "=" * 50
      puts ""
      puts "Fetching credentials from 1Password..."
      puts ""

      Config.setup!

      puts ""
      puts "Setup complete!"
      puts "Config saved to: #{Config::CONFIG_PATH}"
      puts ""
      puts "Next steps:"
      puts "  1. Run 'syncbooks auth fa' if you haven't authenticated with FreeAgent"
      puts "  2. Run 'syncbooks auth sheets' if you haven't authenticated with Google Sheets"
      puts "  3. Run 'syncbooks sync' to sync data to your spreadsheet"
    end

    # === Sync ===

    desc "sync", "Sync FreeAgent data to Google Sheets"
    option :quiet, aliases: "-q", type: :boolean, default: false, desc: "Minimal output"
    option :dev, type: :boolean, default: false, desc: "Use dev spreadsheet"
    def sync
      q = options[:quiet]

      unless q
        puts "Syncing FreeAgent data to Google Sheets"
        puts "=" * 50
        puts ""
      end

      from_date = Config.hst_period_start.to_s
      to_date = Date.today.to_s

      unless q
        puts "HST Period: #{from_date} to #{to_date}"
        puts ""
      end

      hst_charged, hst_reclaimed, _details = calculate_hst(from_date, to_date, quiet: q)
      puts "" unless q

      print "Fetching balance..." unless q
      accounts = fa_client.bank_accounts.select(&:active?)
      balance_total = accounts.sum { |a| a.current_balance || 0 }
      puts " $#{"%.2f" % balance_total}" unless q

      print "Fetching open invoices..." unless q
      open_invoices = fa_client.invoices(view: "open")
      open_total = open_invoices.sum { |i| i.total_value || 0 }
      puts " #{open_invoices.length} invoices ($#{"%.2f" % open_total})" unless q

      print "Fetching overdue invoices..." unless q
      overdue_invoices = fa_client.invoices(view: "overdue")
      overdue_total = overdue_invoices.sum { |i| i.total_value || 0 }
      puts " #{overdue_invoices.length} invoices ($#{"%.2f" % overdue_total})" unless q

      invoices_total = open_total + overdue_total

      print "Fetching open bills..." unless q
      open_bills = fa_client.bills_by_view(view: "open")
      open_bills_total = open_bills.sum { |b| b.total_value || 0 }
      puts " #{open_bills.length} bills ($#{"%.2f" % open_bills_total})" unless q

      print "Fetching overdue bills..." unless q
      overdue_bills = fa_client.bills_by_view(view: "overdue")
      overdue_bills_total = overdue_bills.sum { |b| b.total_value || 0 }
      puts " #{overdue_bills.length} bills ($#{"%.2f" % overdue_bills_total})" unless q

      bills_total = open_bills_total + overdue_bills_total
      puts "" unless q

      unless q
        puts "-" * 50
        puts "Writing to Google Sheets..."
        puts ""
      end

      sheets = GoogleSheetsClient.new(dev: options[:dev])

      writes = {
        "Main!E2" => {label: "HST Collected", value: hst_charged},
        "Main!E3" => {label: "HST Reclaimed", value: hst_reclaimed},
        "Main!E6" => {label: "Available COH", value: balance_total},
        "Main!E9" => {label: "FA Invoices", value: invoices_total},
        "Main!B4" => {label: "Outstanding Bills", value: bills_total}
      }

      writes.each do |range, data|
        sheets.write(range, format("%.2f", data[:value]))
        puts "  #{range.ljust(12)} #{data[:label].ljust(20)} $#{"%.2f" % data[:value]}" unless q
      end

      Config.last_sync = Time.now

      puts "" unless q
      puts "=" * 50 unless q

      if q
        puts "Synced: COH $#{"%.2f" % balance_total} | HST owing $#{"%.2f" % (hst_charged - hst_reclaimed)} | Invoices $#{"%.2f" % invoices_total}"
      else
        puts "Sync complete! (#{Time.now.strftime("%Y-%m-%d %H:%M")})"
        puts ""
        puts "Run 'syncbooks sheets summary' to see updated cash position."
      end
    end

    # === Status ===

    desc "status", "Quick financial position check (from last sync or live)"
    option :live, aliases: "-l", type: :boolean, default: false, desc: "Fetch live data instead of cached"
    def status
      UI.header("Financial Status")
      UI.blank

      last_sync = Config.last_sync
      if last_sync
        UI.muted("Last sync: #{last_sync.strftime("%Y-%m-%d %H:%M")}")
      else
        UI.muted("No sync recorded")
      end
      UI.blank

      if options[:live]
        # Fetch live data
        accounts = fa_client.bank_accounts.select(&:active?)
        balance_total = accounts.sum { |a| a.current_balance || 0 }

        open_invoices = fa_client.invoices(view: "open")
        overdue_invoices = fa_client.invoices(view: "overdue")
        invoices_total = open_invoices.sum { |i| i.total_value || 0 } +
                         overdue_invoices.sum { |i| i.total_value || 0 }

        open_bills = fa_client.bills_by_view(view: "open")
        overdue_bills = fa_client.bills_by_view(view: "overdue")
        bills_total = open_bills.sum { |b| b.total_value || 0 } +
                      overdue_bills.sum { |b| b.total_value || 0 }

        from_date = Config.hst_period_start.to_s
        to_date = Date.today.to_s
        hst_charged, hst_reclaimed, _details = calculate_hst(from_date, to_date, quiet: true)
        hst_net = hst_charged - hst_reclaimed

        rows = [
          ["Available COH", UI.money(balance_total)],
          ["HST Owing", UI.money(hst_net)],
          ["Net COH (after HST)", UI.money(balance_total - hst_net)],
          ["Outstanding Bills", UI.money(bills_total)],
          ["Open Invoices", UI.money(invoices_total)]
        ]
        UI.table(rows, columns: ["Metric", "Amount"])

        UI.blank
        net_position = balance_total - hst_net - bills_total
        UI.success("Net Position (COH - HST - Bills): #{UI.money(net_position)}")
      else
        # Read from spreadsheet
        sheets = GoogleSheetsClient.new
        data = sheets.read("Main!D2:E14")
        assets = data["values"] || []

        data = sheets.read("Main!A2:B11")
        liabilities = data["values"] || []

        coh = liabilities.dig(9, 1)&.gsub(/[^\d.-]/, "")&.to_f || 0
        net_coh = assets.dig(5, 1)&.gsub(/[^\d.-]/, "")&.to_f || 0
        hst_owing = liabilities.dig(0, 1)&.gsub(/[^\d.-]/, "")&.to_f || 0
        bills = liabilities.dig(2, 1)&.gsub(/[^\d.-]/, "")&.to_f || 0
        invoices = assets.dig(9, 1)&.gsub(/[^\d.-]/, "")&.to_f || 0

        rows = [
          ["Available COH", assets.dig(4, 1) || "-"],
          ["HST Owing", liabilities.dig(0, 1) || "-"],
          ["Net COH", assets.dig(5, 1) || "-"],
          ["Outstanding Bills", liabilities.dig(2, 1) || "-"],
          ["Open Invoices", assets.dig(9, 1) || "-"]
        ]
        UI.table(rows, columns: ["Metric", "Amount"])

        UI.blank
        UI.muted("Use --live to fetch current data from FreeAgent")
      end
    end

    # === Contacts ===

    desc "contacts", "List contacts"
    option :view, default: "active", desc: "View: active, all, clients, suppliers"
    option :json, type: :boolean, default: false, desc: "Output as JSON"
    def contacts
      ctcs = fa_client.contacts(view: options[:view])

      if options[:json]
        data = ctcs.map { |c| {id: c.id, name: c.display_name, email: c.email, status: c.status} }
        puts JSON.pretty_generate(data)
        return
      end

      UI.header("Contacts (#{options[:view]})")
      UI.blank

      if ctcs.empty?
        UI.muted("No contacts found.")
        return
      end

      rows = ctcs.map { |c| [c.id, c.display_name, c.email || "-", c.status] }
      UI.table(rows, columns: ["ID", "Name", "Email", "Status"])

      UI.blank
      UI.muted("#{ctcs.length} contacts")
    end

    desc "contact ID_OR_NAME", "Show contact details (accepts ID or name)"
    def contact(input)
      c = resolve_contact_for_display(input)
      puts JSON.pretty_generate(
        id: c.id,
        organisation_name: c.organisation_name,
        first_name: c.first_name,
        last_name: c.last_name,
        email: c.email,
        country: c.country,
        status: c.status
      )
    end

    desc "create-contact", "Create a new contact"
    option :organisation, aliases: "-o", desc: "Organisation name"
    option :first_name, aliases: "-f", desc: "First name"
    option :last_name, aliases: "-l", desc: "Last name"
    option :email, aliases: "-e", desc: "Email address"
    option :billing_email, desc: "Billing email (defaults to email)"
    option :phone, aliases: "-p", desc: "Phone number"
    option :address, aliases: "-a", desc: "Street address"
    option :town, desc: "City/Town"
    option :region, desc: "Province/State/Region"
    option :postcode, desc: "Postal/ZIP code"
    option :country, default: "Canada", desc: "Country"
    option :payment_terms, aliases: "-t", type: :numeric, default: 30, desc: "Payment terms in days"
    def create_contact
      attrs = {}
      attrs[:organisation_name] = options[:organisation] if options[:organisation]
      attrs[:first_name] = options[:first_name] if options[:first_name]
      attrs[:last_name] = options[:last_name] if options[:last_name]
      attrs[:email] = options[:email] if options[:email]
      attrs[:billing_email] = options[:billing_email] || options[:email]
      attrs[:phone_number] = options[:phone] if options[:phone]
      attrs[:address1] = options[:address] if options[:address]
      attrs[:town] = options[:town] if options[:town]
      attrs[:region] = options[:region] if options[:region]
      attrs[:postcode] = options[:postcode] if options[:postcode]
      attrs[:country] = options[:country]
      attrs[:default_payment_terms_in_days] = options[:payment_terms]
      attrs[:locale] = "en"
      attrs[:charge_sales_tax] = "Auto"

      if attrs[:organisation_name].nil? && (attrs[:first_name].nil? || attrs[:last_name].nil?)
        raise Thor::Error, "Must provide --organisation OR both --first-name and --last-name"
      end

      contact = fa_client.create_contact(attrs)
      puts JSON.pretty_generate(id: contact.id, name: contact.display_name, email: contact.email)
      puts "Contact created successfully."
    end

    # === Invoices ===

    desc "invoices", "List invoices"
    option :view, default: "recent", desc: "View: recent, open, all, overdue, draft"
    option :json, type: :boolean, default: false, desc: "Output as JSON"
    def invoices
      invs = fa_client.invoices(view: options[:view])

      if options[:json]
        data = invs.map do |inv|
          {id: inv.id, reference: inv.reference, contact_id: inv.contact_id,
           dated_on: inv.dated_on, due_on: inv.due_on, status: inv.status,
           total: inv.display_total, currency: inv.currency}
        end
        puts JSON.pretty_generate(data)
        return
      end

      UI.header("Invoices (#{options[:view]})")
      UI.blank

      if invs.empty?
        UI.muted("No invoices found.")
        return
      end

      rows = invs.map do |inv|
        [inv.reference || inv.id, inv.dated_on, inv.due_on, inv.status, inv.display_total]
      end
      UI.table(rows, columns: ["Ref", "Date", "Due", "Status", "Total"])

      UI.blank
      total = invs.sum { |i| i.total_value || 0 }
      UI.muted("#{invs.length} invoices â€¢ Total: #{UI.money(total)}")
    end

    desc "invoice ID", "Show invoice details (accepts ID or reference number)"
    def invoice(id)
      inv = resolve_invoice(id)
      puts JSON.pretty_generate(
        id: inv.id,
        reference: inv.reference,
        contact_id: inv.contact_id,
        dated_on: inv.dated_on,
        due_on: inv.due_on,
        status: inv.status,
        net_value: inv.net_value,
        sales_tax_value: inv.sales_tax_value,
        total_value: inv.total_value,
        currency: inv.currency
      )
    end

    desc "create-invoice", "Create a new invoice"
    option :contact, aliases: "-c", required: true, desc: "Contact ID or name"
    option :reference, aliases: "-r", desc: "Invoice reference/number"
    option :date, aliases: "-d", default: Date.today.to_s, desc: "Invoice date (YYYY-MM-DD)"
    option :due_days, aliases: "-t", type: :numeric, default: 30, desc: "Payment terms in days"
    option :currency, default: "CAD", desc: "Currency code"
    option :description, aliases: "-D", required: true, desc: "Line item description"
    option :quantity, aliases: "-q", type: :numeric, default: 1, desc: "Quantity"
    option :price, aliases: "-p", required: true, type: :numeric, desc: "Price per unit"
    option :item_type, default: "Services", desc: "Item type: Hours, Days, Services, Products"
    option :tax_rate, type: :numeric, default: 15.0, desc: "Sales tax rate (%)"
    option :send, type: :boolean, default: false, desc: "Mark as sent after creation"
    def create_invoice
      contact_id = resolve_contact(options[:contact])
      contact_url = "#{FreeAgentClient::BASE_URL}/contacts/#{contact_id}"

      dated_on = Date.parse(options[:date])
      due_on = dated_on + options[:due_days]

      attrs = {
        contact: contact_url,
        dated_on: dated_on.to_s,
        due_on: due_on.to_s,
        payment_terms_in_days: options[:due_days],
        currency: options[:currency],
        invoice_items: [
          {
            description: options[:description],
            item_type: options[:item_type],
            quantity: options[:quantity].to_s,
            price: options[:price].to_s,
            sales_tax_rate: options[:tax_rate].to_s
          }
        ]
      }
      attrs[:reference] = options[:reference] if options[:reference]

      inv = fa_client.create_invoice(attrs)

      if options[:send]
        fa_client.mark_invoice_sent(inv.id)
        puts "Invoice marked as sent."
      end

      puts JSON.pretty_generate(
        id: inv.id,
        reference: inv.reference,
        dated_on: inv.dated_on,
        due_on: inv.due_on,
        status: inv.status,
        total_value: inv.display_total,
        currency: inv.currency
      )
      puts "Invoice created successfully."
    end

    # === Balance ===

    desc "balance", "Show total balance across all bank accounts"
    def balance
      accounts = fa_client.bank_accounts.select(&:active?)

      if accounts.empty?
        UI.warning("No active bank accounts found.")
        return
      end

      bank_accts = accounts.select(&:bank?)
      credit_cards = accounts.select(&:credit_card?)
      paypal = accounts.select(&:paypal?)

      bank_total = bank_accts.sum { |a| a.current_balance || 0 }
      credit_total = credit_cards.sum { |a| a.current_balance || 0 }
      paypal_total = paypal.sum { |a| a.current_balance || 0 }
      total = accounts.sum { |a| a.current_balance || 0 }

      currency = accounts.first.currency || "CAD"

      UI.header("FreeAgent Balance")
      UI.blank

      # Account rows
      rows = accounts.map do |a|
        [a.name, a.currency, UI.money(a.current_balance || 0)]
      end
      UI.table(rows, columns: ["Account", "Currency", "Balance"])

      UI.blank
      UI.section("Totals by Type")
      totals = [
        ["Bank Accounts", currency, UI.money(bank_total)],
        ["Credit Cards", currency, UI.money(credit_total)],
        ["PayPal", currency, UI.money(paypal_total)]
      ]
      UI.table(totals, columns: ["Type", "Currency", "Balance"])

      UI.blank
      UI.success("Total: #{UI.money(total)} #{currency}")
    end

    # === HST ===

    desc "hst", "Calculate HST report (defaults: period start to today)"
    option :from, aliases: "-f", desc: "Start date (YYYY-MM-DD), defaults to HST period start"
    option :to, aliases: "-t", desc: "End date (YYYY-MM-DD), defaults to today"
    def hst
      from_date = options[:from] || Config.hst_period_start.to_s
      to_date = options[:to] || Date.today.to_s

      period_start = Config.hst_period_start
      quarter_name = Config.quarter_name(period_start)

      UI.header("HST Report")
      UI.blank
      UI.info("Period", "#{from_date} to #{to_date} (#{quarter_name})")
      UI.blank

      calculator = HstCalculator.new(fa_client)
      result = calculator.calculate(from_date: from_date, to_date: to_date)

      UI.blank
      UI.section("HST Charged (on sales)")
      charged_rows = [
        ["Invoices", UI.money(result.invoice_hst)],
        ["Bank transactions (income)", UI.money(result.bank_charged)],
        ["TOTAL CHARGED", UI.money(result.charged)]
      ]
      UI.table(charged_rows, columns: ["Source", "Amount"])

      UI.blank
      UI.section("HST Reclaimed (on purchases)")
      reclaimed_rows = [
        ["Bills", UI.money(result.bills_hst)],
        ["Expenses", UI.money(result.expenses_hst)],
        ["Bank transactions (expenses)", UI.money(result.bank_reclaimed)],
        ["Bad debt relief (write-offs)", UI.money(result.bad_debt_hst)],
        ["TOTAL RECLAIMED", UI.money(result.reclaimed)]
      ]
      UI.table(reclaimed_rows, columns: ["Source", "Amount"])

      UI.blank
      UI.success("Net HST Owing to CRA: #{UI.money(result.net_owing)}")
    end

    desc "hst-paid", "Mark HST quarter as paid and advance to next quarter"
    option :confirm, type: :boolean, default: false, desc: "Skip confirmation prompt"
    def hst_paid
      current_start = Config.hst_period_start
      current_quarter = Config.quarter_name(current_start)
      next_start = Config.next_quarter_start
      next_quarter = Config.quarter_name(next_start)

      puts "HST Period Update"
      puts "=" * 50
      puts ""
      puts "Current period start: #{current_start} (#{current_quarter})"
      puts "New period start:     #{next_start} (#{next_quarter})"
      puts ""

      unless options[:confirm]
        print "Advance HST period to #{next_quarter}? (y/N) "
        response = $stdin.gets&.chomp&.downcase
        unless response == "y"
          puts "Cancelled."
          return
        end
      end

      Config.hst_period_start = next_start
      puts ""
      puts "HST period advanced to #{next_quarter} (starting #{next_start})."
      puts "Run 'syncbooks hst' to see the new period totals."
    end

    desc "hst-set DATE", "Set HST period start date (e.g., 2025-10-01)"
    def hst_set(date)
      parsed_date = Date.parse(date)
      Config.hst_period_start = parsed_date
      puts "HST period start set to #{parsed_date} (#{Config.quarter_name(parsed_date)})."
    rescue ArgumentError
      raise Thor::Error, "Invalid date format. Use YYYY-MM-DD."
    end

    desc "hst-status", "Show current HST period configuration"
    def hst_status
      period_start = Config.hst_period_start
      quarter_name = Config.quarter_name(period_start)
      next_quarter = Config.next_quarter_start
      days_in_period = (Date.today - period_start).to_i

      puts "HST Period Status"
      puts "=" * 50
      puts ""
      puts "Period start:     #{period_start} (#{quarter_name})"
      puts "Today:            #{Date.today}"
      puts "Days in period:   #{days_in_period}"
      puts "Next quarter:     #{next_quarter} (#{Config.quarter_name(next_quarter)})"
      puts ""
      puts "Config file: #{Config::CONFIG_PATH}"
    end

    # === Utility ===

    desc "company", "Show company info"
    def company
      c = fa_client.company
      puts JSON.pretty_generate(
        name: c.name,
        type: c.type,
        currency: c.currency,
        registration_number: c.company_registration_number,
        hst_number: c.hst_number,
        hst_status: c.sales_tax_registration_status
      )
    end

    desc "projects", "List projects"
    option :contact, aliases: "-c", desc: "Filter by contact ID"
    option :json, type: :boolean, default: false, desc: "Output as JSON"
    def projects
      projs = fa_client.projects(contact_id: options[:contact])

      if options[:json]
        data = projs.map do |p|
          { id: p.id, name: p.name, contact_id: p.contact_id, status: p.status,
            budget: p.display_budget, currency: p.currency }
        end
        puts JSON.pretty_generate(data)
        return
      end

      UI.header("Projects")
      UI.blank

      if projs.empty?
        UI.muted("No projects found.")
        return
      end

      rows = projs.map do |p|
        [p.id, p.name, p.status, p.display_budget || "-", p.currency]
      end
      UI.table(rows, columns: ["ID", "Name", "Status", "Budget", "Currency"])

      UI.blank
      UI.muted("#{projs.length} projects")
    end

    private

    def fa_client
      @fa_client ||= FreeAgentClient.new
    end

    def resolve_contact(input)
      return input if input.match?(/^\d+$/)

      contact = fa_client.find_contact_by_name(input)
      raise Thor::Error, "Contact not found: #{input}" unless contact

      contact.id
    end

    def resolve_contact_for_display(input)
      # If it's a numeric ID, fetch directly
      if input.match?(/^\d+$/)
        begin
          return fa_client.contact(input)
        rescue RuntimeError => e
          if e.message.include?("404")
            raise Thor::Error, "Contact not found with ID '#{input}'."
          end
          raise
        end
      end

      # Otherwise search by name
      contact = fa_client.find_contact_by_name(input)
      raise Thor::Error, "Contact not found: '#{input}'. Try searching with 'syncbooks contacts' first." unless contact
      contact
    end

    def resolve_invoice(input)
      # Short numbers (<=5 digits) are likely reference numbers, longer are FreeAgent IDs
      if input.match?(/^\d+$/) && input.length <= 5
        inv = fa_client.find_invoice_by_reference(input)
        raise Thor::Error, "Invoice not found with reference '#{input}'. Try using the full FreeAgent ID instead." unless inv
        return inv
      end

      # Try as FreeAgent ID
      begin
        fa_client.invoice(input)
      rescue RuntimeError => e
        if e.message.include?("404")
          raise Thor::Error, "Invoice not found with ID '#{input}'. If this is a reference number, it may not be in recent/open/overdue/draft views."
        end
        raise
      end
    end

    def extract_id(url)
      return nil unless url
      url.split("/").last
    end
  end
end

SyncBooks::CLI.start(ARGV)
